### React 15
- `React`는 `UI`를 조작하는 선언적인 방법 제공
- 직접 `UI`의 개별 요소를 조작하는 대신 컴포넌트가 취할 수 있는 다양한 상태를 설명하고, 사용자 입력에 대한 상태 변경을 보여준다.

#### 명령적 UI
- 명령적 프로그래밍에서는 상호작용을 구현하는 방식으로 직접 조작
- 발생한 사건에 따라 `UI`를 조작하는 정확한 명령을 작성
- 상태를 업데이트하는 코드만 작성
- 스피너에서 버튼까지 각 요소를 명령하여 컴퓨터에게 `UI`를 업데이트하는 방법
- 명령적 프로그래밍에서는 독립된 예제에서는 잘 작동하지만, 더 복잡한 시스템에서는 관리하기가 어려워짐.
- `React`에서는 `UI`를 직접 조작하지 않음
- 표시할 `UI`를 설명하고, `React`가 `UI`를 업데이트하는 방법을 결정한다.

#### 선언적 UI
- 컴포넌트의 다른 시각적 상태 확인
 1. `UI` 상태 시각화
- 상태 변경을 트리거하는 입력 확인
- `useState`를 사용하여 상태를 메모리에 표현
- 필요하지 않은 상태 변수 제거
- 이벤트 핸들러를 연결하여 상태 설정

### React 16

#### 상태 구조화
- 상태 구조화는 수정 및 디버깅이 쉬운 컴포넌트와 버그가 계속 발생하는 컴포넌트 간의 차이를 만들수 있음
- 상태 구조화 원칙
  1. 관련된 상태 그룹화
  2. 상태에서 모순을 피한다. 
  3. 중복 상태 피하기
  4. 상태에서 중복을 피하기
  5. 깊게 중첩된 상태를 피한다.
- 데이터베이스 정규화와 비슷한 방식
- 상태 변수가 객체인 경우, 다른 필드를 명시적으로 복사하지 않고는 하나의 필드만 업데이트할 수 없다. 하나로 통합하는 것을 고려
- 중첩된 상태 업데이트는 변경된 부분에서부터 상위 부분까지 객체를 복사하는 것
- 깊게 중첩된 장소를 삭제하는 경우, 해당 장소의 전체 부모 장소 체인을 복사해야함
- 상태가 너무 깊게 중첩되어 업데이트하기 어려운경우, `평평하게(정규화)` 만드는것을 고려해야함.
- **불가능한**상태를 만들지 않도록 주의.
- 특별한 경우가 아니라면 `props`을 상태로 넣지 말아야함
- 선택과 같은 `UI` 패턴의 경우 객체 자체 대신 `ID`나 인덱스를 상태로 유지

### React 17
- 두 컴포넌트의 상태가 항상 같이 변경되게 하려고 하는 경우
- 두 컴포넌트에 상태를 제거하고, 가장 가까운 공통 부모 컴포넌트로 이동시킨 다음, `props`를 통해 컴포넌트를 전달하는것
- 상태를 **위로 올리는 것** 이라고 한다.

#### 상태 위로 올리기
- 자식 컴포넌트에서 상태를 제거
- 공통 부모에서 하드코딩된 데이터를 전달
- 공통 부모에 상태를 추가하고 이벤트 핸들러와 함께 하위 컴포넌트에 전달

#### 제어 컴포넌트
- 중요한 정보가 로컬 상태가 아니라 `props`에 의해 결정되는 경우 컴포넌트를 **제어 컴포넌트** 라고 함.
- 부모 컴포넌트가 해당 컴포넌트의 동작을 완전히 지정할 수 있게 함.
- 여러 컴포넌트를 함께 조율하는 경우 사용됨 

#### 비제어 컴포넌트
- 로컬 상태를 가진 컴포넌트를 **비제어 컴포넌트** 라고 부른다.
- 구성이 덜 필요하기 때문에 부모 컴포넌트 내에서 사용하기 쉬움
- 여러 컴포넌트를 함께 조율하는 경우 제어 컴포넌트보다 유연하지 못함.